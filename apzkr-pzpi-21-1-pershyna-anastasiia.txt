Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації обліку догляду за рослинами 


Студент гр. ПЗПІ-21-1                                           Першина А.А.		
                                                                 (підпис)
Керівник роботи                                                   доц. Лещинський В.О.
(підпис)
Роботу захищено «    »                  2024 р.
з оцінкою                                             -                                  
 
Комісія:                                                                            доц. Лещинський В.О.
                         (підпис)
                                                                                                                доц. Лещинська І.О.
                         (підпис)
                                                                                                                ст. викл. Сокорчук І.П.
                         (підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук            Кафедра програмної інженерії                 
Спеціальність 121 – Інженерія програмного забезпечення                                   
Курс          3          Семестр                                  6                                                    -      
Навчальна дисципліна Архітектура програмного забезпечення                         -      

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

__________________Першині Анастасії Андріївні   ______________________
1. Тема роботи: «Програмна система для автоматизації догляду за рослинами»                                                                                                              -  
2. Термін узгодження завдання курсової роботи «11»   березня  2024 р. 
3. Термін здачі студентом закінченої роботи «10»    червня        2024 р.  
4. Вихідні дані до проєкту (роботи): Програмна система для автоматизації обліку догляду за рослинами, яка призначена для компаній, що надають послуги догляду за рослинами. Дана система має бути масштабованою, орієнтованою на користувача, з інтуїтивно зрозумілим інтерфейсом. Вона складається з серверної частини, клієнтської частини та мобільного застосунку. Використовувати СКБД Microsoft SQL Server, середовища розробки Microsoft Visual Studio, Microsoft Visual Studio Code, Android Studio.. 
5. Зміст пояснювальної записки (перелік питань, що належить  розробити): аркуш завдання, опис Vision & Scope, опис прийнятих інженерних рішень серверної частини, опис методів обробки даних, програмний код серверної частини, опис прийнятих інженерних рішень клієнтської частини, програмний код клієнтської частини, опис прийнятих інженерних рішень мобільного застосунку.
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма компонентів, UML діаграма станів, UML діаграма діяльності     .





КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1	Функціональна специфікація програмного проекту	30.03.2024	виконано
2	Проектування програмного проекту	14.04.2024	виконано
3	Кодування програмного проекту	30.05.2024	виконано
4	Оформлення пояснювальної записки	05.06.2024	виконано
5	Захист курсової роботи	11.06.2024	виконано


Дата видачі завдання «   11   »        березня           2024 р.  


Керівник                                                                  доц. Лещинський В.О.
                                                                      (підпис)

Завдання прийняла до виконання 
ст. гр. ПЗПІ-21-1                                                                   Першина А.А
                                                                                    (підпис)




РЕФЕРАТ


Пояснювальна записка до курсової роботи: 77 с., 24 рис., 2 таблиці, 5 додатків, 5 джерел. 
АДМІНІСТРАТОР, ДОГЛЯД ЗА РОСЛИНАМИ, ОБЛІК, ОБСЛУГОВУЮЧА КОМПАНІЯ, ПРАЦІВНИК, ПРОГРАМНА СИСТЕМА, РОСЛИНИ.

Для виконання роботи було обрану таку тему, як автоматизація обліку догляду за рослинами. Назва системи, розробленої в рамках проєкту, – “GreenGuard”. 
Метою курсової роботи є розробка програмної системи, яка допомагає автоматизувати роботу компанії, що надає послуги догляду за рослинами. Система спрямована на забезпечення легкого ведення обліку та контролю працівників, завдань, наявних рослин, добрив, шкідників та типів рослин. Вона дозволяє користувачам легко відстежувати статуси завдань, стани рослин, робочі години працівників та графіки поливів. Крім того, система підтримує локалізацію та створення резервних копій бази даних.
Програмна система складається з бази даних, що була розроблена у середовищі Microsoft SQL Server; серверної частина, яка була зроблена за допомогою технології ASP.NET на мові програмування C#; веб застосунку, розробленого на мові програмування JavaScript; мобільного додатку, який було створено у середовищі розробки Android Studio на мові програмування Kotlin.
У результаті було розроблено програмну реалізацію системи автоматизації обліку догляду за рослинами. Програмна система складається з сервера, вебсайту та мобільного застосунку.


ЗМІСТ

ВСТУП	8
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1 Бізнес-вимоги	9
1.1.1 Бізнес-можливості	9
1.1.2 Бізнес-цілі та критерії успіху	10
1.1.3 Потреби клієнтів або ринку	11
1.1.4 Бізнес-ризики	12
1.2 Концепція рішення	13
1.2.1 Окреслення концепції	13
1.2.2 Головна функціональність	14
1.2.3 Припущення та залежності	15
1.3 Рамки та обмеження проєкту	16
1.3.1 Рамки первинного випуску	16
1.3.2 Рамки наступних випусків	17
1.3.3 Обмеження та винятки	18
1.4 Бізнес-контекст	19
1.4.1 Профілі зацікавлених сторін	19
1.4.2 Пріоритети проєкту	20
1.4.3 Робоче середовище	21
2 КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ	23
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	25
4 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ	27
4.1  Використані технології	27
4.2  Розробка сервера в програмному середовищі	28
4.3 Тестування	31
5 РОЗРОБКА ВЕБ ЧАСТИНИ	32
6 РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ	35
7 ОПИС ПРОГРАМНОЇ СИСТЕМИ	39
7.1 Виклик і завантаження	39
7.2 Опис веб частини	40
7.3 Опис мобільного застосунку	45
ВИСНОВКИ	52
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	53
ДОДАТОК А	54
ДОДАТОК Б	56
ДОДАТОК В	58
ДОДАТОК Г	59
ДОДАТОК Д	60







ВСТУП


Люди завжди мали прихильність до домашніх рослин, які не тільки прикрашають життя, а й очищують повітря. Флора активно використовується для покращення дизайну приміщень, завдяки своїй здатності додавати природну красу та живий колорит до будь-якого інтер'єру. 
Зараз складно знайти ресторан, торговельно-розважальний чи офісний центр без кімнатних рослин. Власники компаній та дизайнери інтер’єрів активно збагачують приміщення флорою. Проте, навіть при всіх перевагах, рослини потребують постійного догляду та турботи. Особливо це стосується екзотичних видів, які потребують специфічних умов – правильного освітлення, вологого режиму, регулярного захисту від шкідників і хвороб, а також точної кількості води.
У великих приміщеннях, таких як офіси чи торговельні центри, догляд за рослинами часто перекладається на компанії, що надають послуги прибирання. Однак ці компанії стикаються з численними проблемами. Наприклад, неправильний полив може призвести до загибелі рослин, невідповідне освітлення уповільнює їх ріст, а відсутність своєчасного оброблення від шкідників може пошкодити не тільки окремі екземпляри, а й всю колекцію. Через відсутність спеціалізованого програмного забезпечення облік і контроль за доглядом за рослинами ведеться вручну, що часто призводить до помилок та недоглядів.
Система “GreenGuard” вирішує ці проблеми, автоматизуючи контроль догляду за рослинами та роблячи цей процес легким та ефективним. “GreenGuard” пропонує рішення для моніторингу та управління всіма аспектами догляду за рослинами, включаючи регулювання вологості, освітлення, графіки поливу та обробки від шкідників. Це дозволяє забезпечити оптимальні умови для рослин, мінімізуючи ризики та зусилля, пов’язані з їх утриманням.

1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Система “GreenGuard” спрямована на глобальний ринок, головні покупці – компанії, які займаються доглядом за рослинами, чи компанії, які надають послуги прибирання. 
Розглянемо аналоги, що вже існують. Програмне забезпечення для догляду за рослинами “Arborgold” розроблено для компаній, пов’язаних із роботою з флорою, які шукають централізовану базу даних для своїх клієнтів, щоб вони могли покращити процес подання заявок, автоматизувати подальші дії, ефективно планувати графіки, відстежувати бригади, зменшити накладні витрати та спростити виставлення рахунків. 
Основні функції:
- Централізована база даних клієнтів
- Автоматизація подання заявок та подальших дій
- Ефективне планування графіків
- Відстеження бригад
Переваги:
- Інтерактивна мапа для візуалізації рослин
- Спрощений облік та планування
Недоліки:
- Відсутність інтеграції з датчиками для моніторингу стану рослин у реальному часі
 “Lifeasible” – програмне забезпечення для керування ростом рослин, є ще одним аналогом для системи “GreenGuard”. “Lifeasible” є великою системою, що включає у себе сервіси для управління теплицями, боротьби з бур’янами та паразитичними рослинами і прогнозування появи шкідників. 
Основні функції:
- Управління теплицями
- Прогнозування появи шкідників
- Використання штучного інтелекту для ідентифікації бур’янів та паразитичних рослин
Переваги:
- Широкий спектр функцій для комплексного догляду за рослинами
- Використання штучного інтелекту для покращення управління
Недоліки:
- Висока вартість і надлишковий функціонал для потреб офісів та торговельних центрів
Система “GreenGuard” призначена виключно для кімнатних рослин, що робить її більш спеціалізованою у порівнянні з “Arborgold” та “Lifeasible”. Вона проста у використанні і не містить надлишкових функцій.
Система “GreenGuard” є платною, з двома варіантами підписки – річна та на 6 місяців. Після закінчення підписки користувачі втрачають доступ до системи. Така модель обрана з метою забезпечення стабільного доходу та можливості оновлення і покращення функціоналу системи. Відсутність додаткових платежів робить модель прозорою та привабливою для клієнтів.


1.1.2 Бізнес-цілі та критерії успіху


BO-1: Надати користувачам можливість ефективно вести облік догляду за рослинами
BO-2: Економити час, який компанії витрачають на догляд за рослинами
BO-3: Зробити користувачам єдину базу даних, у якій буде зберігатися вся інформація про рослини
BO-4: Забезпечити фінансову стійкість продукту
BO-5: Полегшити процес обліку догляду за рослинами завдяки зручному та інтуїтивно зрозумілому інтерфейсу системи
SC-1: Залучити не менше 1000 користувачів протягом перших 5 місяців експлуатації, із яких принаймні 75% будуть продовжувати підписку на наступні роки.
SC-2: Забезпечити безперебійну роботу системи з об’ємами даних, які перевищують 500 гігабайт.
SC-3: Забезпечити можливість використання системи декількома мовами задля залучення клієнтів із різних країн 
SC-4: Підвищення рівня задоволеності користувачів до 80% протягом перших 6 місяців, виміряно на основі регулярних опитувань клієнтів та зворотного зв'язку.
SC-5: Закрити перший фінансовий рік з рівнем прибутку не менше $50,000
SC-6: Збільшення обсягу продажів на 30% відносно першого кварталу в кожному наступному кварталі першого року роботи.


1.1.3 Потреби клієнтів або ринку


Організації, які знаходяться в офісних або торгових приміщеннях, прагнуть підтримувати приємну атмосферу для своїх працівників та клієнтів, адже це має прямий вплив на їхній прибуток. Додавання кімнатних рослин є дієвим способом швидко підвищити привабливість приміщення.
В умовах швидкого ритму життя та загального підвищення темпу роботи, оптимальне використання часу стає ключовим фактором успіху для будь-якої компанії. Автоматизація процесів догляду за кімнатними рослинами надає можливість значно економити час та ресурси, необхідні для виконання цих завдань. Менеджери компаній, які надають послуги догляду за рослинами, шукають рішення для ефективного ведення обліку їхніх приміщеннях. Система “GreenGuard” дозволяє вести весь облік у зручному програмному забезпеченні, щоб компанії могли відмовитись від великої кількості застарілої паперової документації.
Менеджери офісів та торгових центрів, які можуть працювати віддалено та не бути фізично присутніми в приміщенні, потребують можливості моніторингу стану рослин на відстані. “GreenGuard” забезпечує можливість отримання оновлень та сповіщень про стан рослин що дозволяє ефективно віддалено керувати процесами догляду.


1.1.4 Бізнес-ризики


Конкуренція на ринку зазвичай є одним із головних ризиків, адже поява продуктів-конкурентів або послуг з подібними функціями може призвести до зменшення попиту на систему “GreenGuard” та зниження прибутковості. Проте “GreenGuard” має специфічний функціонал для конкретних цільових покупців, тому наразі наявність продуктів-конкурентів не є першочерговим ризиком.
Одним із головних ризиків є той факт, що деякі компанії можуть бути консервативними у своїх підходах до технологічних змін і не бажати впроваджувати нові цифрові системи через страх перед непередбачуваними або складними переходами. Це може стати перешкодою для прийняття системи “GreenGuard”. Щоб уникнути цей ризик, необхідно розробити систему інтуїтивно зрозумілою та подібною до традиційних методів обліку, щоб співробітникам не доводилося довго розбиратися у функціоналі. У такому разі компанії отримають зручну цифрову систему, яка пропонує значні переваги у порівнянні зі старими паперовими методами обліку.
Ще одним можливим ризиком є проблеми з технічним аспектом системи, а саме нестабільність у функціональності, ненадійність або проблеми з масштабуванням. Цей ризик є вагомим, бо технічні проблеми в роботі системи, можуть мати вкрай негативний вплив на досвід використання. Дана проблема може призвести до втрати користувачів та погіршення репутації системи серед потенційних покупців. Саме тому перед запуском “GreenGuard” у продаж, система має бути протестована потенційними покупцями, щоб розробники одразу могли отримати відгуки від користувачів та виправити можливі недоліки.


1.2 Концепція рішення
1.2.1 Окреслення концепції


“GreenGuard” – це програмна система, призначена для автоматизації та оптимізації обліку догляду за рослинами у торгових, розважальних та офісних центрах. Цей програмний продукт розроблений з метою надання компаніям зручного та ефективного інструменту для моніторингу, керування та підтримки здоров'я та краси рослин у їхніх приміщеннях.
“GreenGuard” пропонує користувачам з усього світу зручну цифрову систему для легкого ведення обліку догляду за рослинами. Мобільний додаток дозволяє співробітникам вносити дані про різні маніпуляції з рослинами. Адміністратор системи може змінювати наявні дані про рослини, створювати завдання на кшталт поливів та назначати людей, які повинні це виконати. 
Система забезпечує можливість постійного моніторингу параметрів росту та здоров'я рослин, таких як вологість ґрунту, освітленість та температура завдяки сенсорам, встановленим у горщики з рослинами. Таким чином адміністратор може бачити, як змінюються різні показники після поливів чи внесення добрив. Окрім того, “GreenGuard” надає користувачам систему попереджень та сповіщень про виявлені проблеми, такі як нестача води, шкідники або хвороби, що дозволяє швидко реагувати та запобігати загрозам для рослин.
У системі “GreenGuard” є база даних із інформацією про рослини, проте користувачі можуть редагувати та доповнювати ці дані, тим самим роблячи їх більш персоналізованими. Таким чином систему можна використовувати як довідник з порадами щодо догляду за різними видами фауни.
“GreenGuard” є зручним інструментом, який дозволяє компаніям, що надають послуги догляду за рослинами, значно оптимізувати їх робочий процес.


1.2.2 Головна функціональність


Зі сторони вебсайту (для адміністраторів):
MF-1: Вхід до системи адміністраторами
MF-2: Створення завдань адміністраторами
MF-3: Призначення адміністраторами робітників на завдання
MF-4: Редагування та доповнення інформації про рослини
MF-5: Перегляд та редагування списків працівників та рослин
MF-6: Попередження про проблеми з рослинами
MF-7: Моніторинг даних щодо вологості, світла і температури для кожного датчика, що встановлено в рослину
MF-8: Створення та внесення змін у розклади поливу рослин та внесення добрив 
MF-9: Можливість автоматичного створення графіків поливу, завдяки розрахункам, які базуються на інформації про рослину з довідника (як часто її рекомендують поливати) та даних із датчиків вологості та температури
Зі сторони мобільного застосунку (для співробітників):
MF-10: Вхід до системи співробітниками
MF-11: Перегляд призначених завдань
MF-12: Перегляд розкладів поливу та внесення добрив
MF-13: Перегляд інформації про рослини 
MF-14: Редагування робочих годин
MF-15: Перегляд довідника про рослини, що містить рекомендації та поради щодо догляду
MF-16: Можливість відмітити завдання як виконане


1.2.3 Припущення та залежності


Assumption: Клієнти шукають рішення, які дозволять їм ефективно використовувати обмежені ресурси (час, гроші, працю) для догляду за рослинами.
Assumption: Користувачі мають доступ до різноманітних пристроїв, таких як комп'ютери, смартфони або планшети, для використання системи.
Assumption: Система має довідник про рослини, що містить рекомендації та поради щодо догляду.
Assumption: Користувачі системи мають постійній доступ до мережі Інтернет.
Assumption: Облік догляду за рослинами легше вести в цифровому форматі, ніж у паперовому.
Assumption: У системі зберігаються дані про рослини та про співробітників.
Dependency: Успіх системи залежить від того, наскільки вона допомагає зменшити витрати часу та ресурсів та підвищити ефективність робочих процесів.
Dependency: Система повинна працювати на різних типах пристроїв та бути пристосованою до різних розмірів екранів.
Dependency: Мобільний застосунок повинен бути інтуїтивно зрозумілим для співробітників, щоб вони легко перейшли з паперової системи обліку на цифрову.
Dependency: Сталий доступ до мережі Інтернет є необхідним для коректної роботи системи.
Dependency: Система повинна мати високий рівень безпеки та конфіденційності даних.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


Веб-застосунок:
SIR-1: Вхід до системи адміністраторами.
SIR-2: Створення завдань адміністраторами.
SIR-3: Призначення адміністраторами робітників на завдання
SIR-4: Перегляд, редагування та доповнення інформації про рослини.
SIR-5: Перегляд, редагування та доповнення інформації про працівників.
SIR-6: Створення та керування розкладами поливу та внесення добрив.
SIR-7: Налаштування профілю та особистих даних адміністраторів.
SIR-8: Можливість автоматичного створення графіків поливу, базуючись на інформації про рослину та даних із датчиків вологості та температури.
SIR-9: Можливість переглянути рекомендовану заробітну плату для кожного працівника, у залежності від його робочих днів та годин
Мобільний-застосунок:
SIR-10: Вхід до системи співробітниками.
SIR-11: Налаштування профілю та особистих даних співробітників.
SIR-12: Перегляд призначених завдань.
SIR-13: Можливість зміни статусу завдання
SIR-14: Перегляд довідника про рослини, що містить рекомендації та поради щодо догляду.
SIR-15: Перегляд розкладів поливу та внесення добрив для співробітників.
SIR-16: Редагування власних робочих годин.
SIR-17: Перегляд інформації про наявні рослини.
SIR-18: Додавання нових рослин.
SIR-19: Автоматичне встановлення статусів рослинам, у залежності від поточних та рекомендованих рівнів освітлення, вологості та температури.
Сервер:
SIR-20: Прийняття та обробка запитів, які надходять з мобільного та веб-застосунків
SIR-21: Отримання та надіслання запитів до бази даних для отримання та запису інформації.


1.3.2 Рамки наступних випусків


SSR-1: Додавання функціоналу моніторингу вологості повітря та кількості вуглекислого газу.
SSR-2: Прогнозування потреб рослин на основі зібраних даних та рекомендацій щодо оптимального догляду.
SSR-3: Впровадження модуля аналізу зображень для автоматичного виявлення шкідників та хвороб на основі фотографій рослин, отриманих від користувачів.
SSR-4: Інтеграція зі сторонніми платформами для надання користувачам доступу до погодних сервісів, дані з яких будуть використовуватися при розрахунку оптимального графіку поливу.


1.3.3 Обмеження та винятки


LE-1: Система працює коректно лише за умови підключення до мережі Інтернет.
LE-2: Доступ до систему мають тільки ті користувачі, які купили підписку та її термін дії ще не закінчився.
LE-3: Базовий зміст довідника про рослин є обмеженим та містить лише найпопулярніші кімнатні рослини.
LE-4: Співробітники, які не зареєстровані в системі, не можуть бути залучені до виконання завдань.
EX-1: Деякі функції системи можуть бути обмежені або недоступні через технічні або безпекові обмеження, наприклад, відсутність підтримки встановлення додатків сторонніми організаціями.
EX-2: Система не може повністю адаптуватися до індивідуальних потреб кожної рослини.
EX-3: У випадку необхідності проведення технічних робіт, можливе тимчасове обмеження доступу до окремих функцій або всієї системи. Користувачі будуть своєчасно проінформовані про це.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Компанія, яка надає послуги догляду за рослинами	Ефективний облік догляду за рослинами	Очікує, що цифровий облік наданий системою та додаткові 
функції зможуть оптимізувати робочий процес	Підвищення ефективності роботи; зменшення витрат;	Час; робітники; бюджет; ресурси для догляду за рослинами
Співробітники компанії, яка надає послуги догляду за рослинами	Спрощення робочих процесів	Очікує, що система спростить 	Автоматизація частини робочих процесів	Час; необхідність навчитися 
		процес догляду за рослинами та ведення обліку	працювати з системою
Продовження таблиці 1


1.4.2 Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	Випуск 1.0 – до 10.06.2024;
випуск 1.1 – до 01.12.2024	План робіт	Випуск 1.0 – до 10.06.2024;
випуск 1.1 – до 01.12.2024
Функціональність			Не менше 80% функцій із високим пріоритетом повинні бути наявні у випуску 1.0
Якість			У випуску 1.0 повинно пройти 

Продовження таблиці 2
			не менше 95% тестів, у випуску 1.1 – не менше 90%
Персонал		Максимальний розмір команди: 1	
Ціна			Допустимим є перевищення бюджету не більше, ніж на 10% 


1.4.3 Робоче середовище


Система для автоматизації обліку догляду за рослинами “GreenGuard” складається з серверної частини, веб-застосунку та мобільного застосунку.
Для роботи з сервером була обрана мова програмування C#. Засоби розробки в C# включають в себе вбудовані бібліотеки та фреймворки, такі як ASP.NET для веб-розробки, що значно спрощує розробку різноманітних типів додатків.
Для створення бази даних буде використовуватися система управління базами даних MS SQL Server, яка відома своєю надійністю та стабільністю. SQL Server повністю підтримує роботу з C# і .NET Framework, що дозволяє легко звертатися до бази даних з серверної частини програми [1].
Веб-застосунок буде написаний за допомогою HTML, CSS та JavaScript. Це поєднання мови розмітки, каскадних таблиць стилів та мови програмування є популярним, адже вони втрьох мають простий синтаксис та широку підтримку від веб-браузерів [2]. 
Мобільний застосунок буде написаний на платформі Android Studio мовою програмування Kotlin. Kotlin є сучасною мовою, яка має зручний синтаксис, безпеку типів, підтримку різноманітних паттернів програмування та інші переваги, Android Studio має ряд інструментів та функцій, які полегшують розробку та тестування мобільних застосунків.
Середовище, в якому буде використовуватися система “GreenGuard”, є глобальним, оскільки компанія, яка надає послуги догляду за рослинами, може мати клієнтів у різних регіонах світу. 
Основне навантаження на систему буде відбуватись протягом робочих годин з понеділка по п'ятницю, коли користувачі активно працюють на об'єктах догляду за рослинами. Важливо, щоб у цей час система працювала без раптових збоїв. Безперервний доступ до системи може бути критичними для роботи бізнесу користувачів, оскільки догляд за рослинами вимагає своєчасного реагування на проблем.
Захист даних та безпека доступу є критично важливими аспектами для будь-якої сучасної інформаційної системи, особливо якщо в ній зберігаються персональні дані та конфіденційна інформація про робочі процеси. Засоби контролю безпеки доступу та вимоги до захисту даних повинні бути високими, бо в системі будуть зберігатися персональні дані про співробітників компаній та конфіденційна інформація щодо деталей робочого процесу.






2 КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРОГРАМНОЇ СИСТЕМИ


Перед початком роботи над серверною частиною проєкту необхідно зробити аналіз предметної області та потреб користувачів. Система розрахована на користувачів двох типів – працівник та адміністратор. Проте, працівників також можна розділити на авторизованих та неавторизованих. Тому, навіть не зважаючи на те, що існує два типи користувачів, для них існує три рівня доступу.
Користувачами мобільного додатку є працівники компанії, що надає послуги догляду за рослинами. Діаграма прецедентів, яку наведено в додатку А, на рисунку А.1, зображує інформаційні потреби авторизованого та неавторизованого працівників. Неавторизований працівник може зробити єдину дію, а саме авторизуватись та ввести правильну адресу електронної пошти та пароль. Якщо система знайшла у базі даних працівника з такими даними автентифікації, то його статус змінюється із неавторизованого працівника на авторизованого, тим самим змінюючи його рівень доступу.
Система надає авторизованому працівнику доступ до низки функцій, які задовольнятимуть його потреби. Оскільки основною задачею працівника є догляд за рослинами, то він має доступ до списку наявних рослин, де він має змогу додавати, видаляти рослини та редагувати інформацію про них. Також користувач має доступ довідника шкідників і, за потреби, може додавати або видаляти шкідників з рослини. Працівник отримує свої робочі завдання від адміністратора, після чого він зобов’язаний змінити статус завдання, щоб повідомити про хід його виконання. Після виконання завдання працівник змінює статус завдання на «виконано». Для зручності, користувач окремо може переглянути список своїх завдань на сьогодні. Одним із типом завдань є внесення добрива до рослини, тому працівник може переглядати список добрив, додавати та видаляти їх та змінювати їхню наявну кількість. Щоб уникнути понаднормової роботи, працівник має змогу змінювати свої робочі дні та робочі години. Окрім цього, він може змінювати такі особисті дані, а саме ім’я, адреса електронної пошти та номер телефону.
Користувачами вебсайту є адміністратори компанії, що надає послуги догляду за рослинами. Його діаграму прецедентів наведено в додатку А, на рисунку А.2. У даній системі адміністратор може отримати доступ до всіх функцій звичайного працівника, якщо використає мобільний додаток, а також доступ до функцій, пов’язаних із адмініструванням з вебсайту. Ці функції включають у себе доступ до редагування, додавання та видалення даних про рослини. Адміністратор повинен керувати працівниками, тому він має змогу переглянути список, змінити роль чи видалити працівників. Для зручності він також може отримувати розрахунок місячної заробітної плати робітника за допомогою використання математичної моделі. Ще одна важлива частина обов’язків адміністратора полягає у створенні завдань, тому система дозволяє йому переглядати, створювати, редагувати і видаляти завдання, а також додавати та видаляти працівників і рослини із завдань. Окрім цього, адміністратор повинен мати змогу керувати резервними копіями бази даних, а саме переглядати їх список, створювати чи завантажувати резервні копії. Можливість робити резервні копії даних є вкрай важливою, оскільки вона надає додатковий захист від втрати даних та можливість відновлення.








3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ


У ході проєктування бази даних було створено ER-діаграму (рис. 3.1). База даних містить 8 основних таблиць та 38 неключових атрибутів. 

Рисунок 3.1 – ER-діаграма

Розглянемо зв’язки між таблицями:
- види рослин і рослини мають зв’язок один до багатьох, адже може бути багато рослин однакового типу, проте кожна рослина може бути лише одного типу;
- види шкідників та рослини мають зв’язок багато до багатьох, адже у багатьох рослин можуть бути однакові шкідники та кожна рослина може мати більше за одного шкідника;
- завдання та рослини мають зв’язок багато до багатьох, бо в одному завданні може бути багато рослин та кожна рослина може бути в декількох завданнях;
- типи добрив та завдання мають зв’язок один до багатьох, адже в одному завданні може бути лише один тип добрива, але кожен тип добрива може бути в декількох завданнях;
- графіки роботи та працівники мають зв’язок один до одного, адже один робітник може мати лише один графік та кожен графік може належати лише одному працівнику;
- завдання та доручення мають зв’язок один до багатьох, бо одне завдання може мати багато доручень, але кожне доручення належить лише одному завданню;
- працівники та доручення мають зв’язок один до багатьох, бо працівник може бути в багатьох дорученнях, проте кожне доручення може містити лише одного працівника.
    








4 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ
4.1  Використані технології


Для розробки сервера була обрана мова програмування C# та платформа .NET 8 з використанням технології ASP.NET Core Web API, яка забезпечує широкі можливості для розробки REST-додатків на базі .NET Framework [3].
	Для створення бази даних було використано система управління базами даних MS SQL Server, яка відома своєю надійністю та стабільністю. SQL Server повністю підтримує роботу з C# і .NET Framework, що дозволяє легко звертатися до бази даних з серверної частини програми за допомогою технології Entity Framework Core.
	Після аналізу технологій було створено діаграму розгортання (див. рис. 4.1), яка візуалізує взаємодію різних складових проєкту.
Рисунок 4.1 – Діаграма розгортання проєкту
4.2  Розробка сервера в програмному середовищі

Для роботи з базами даних було обрано СУБД MS SQL Server, усього база даних містить 8 основних таблиць та 2 допоміжні. Для розробки сервера було обрано мову програмування C# та технологію ASP.NET. Для забезпечення конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передачі. Доступ із сервера до бази даних здійснюється за допомогою технології Entity Framework Core, яка надає інтерфейс для взаємодії з базою даних у вигляді об’єктів сутностей. 
Для автентифікації користувачів використовуються JWT (JSON Web Token). Вони є стандартом відкритого обміну токенів, який дозволяє безпечно передавати інформацію між сторонами у вигляді JSON об'єкта. JWT токени є гнучким механізмом для забезпечення безпеки та автентифікації. Вони дозволяють зменшити навантаження на сервер і дозволяють побудувати безпечні та масштабовані додатки.
В архітектурі сервера важливими складовими є DTO (data transfer objects), моделі, контролери та сервіси. 
DTO повністю повторюють структуру сутностей із бази даних та передбачають зручну взаємодію між різними шарами проєкту, проте не містять в собі жодної логіки. Моделі теж є представленнями даних у тому форматі, у якому вони використовуються програмою, вони містять у собі перевірку правильності вводу даних.
Контролери відповідають за обробку HTTP запитів від клієнтів, тобто вони приймають запити, взаємодіють з моделями та сервісами для виконання потрібних дій, та повертають відповідь клієнту. Сервіси містять бізнес-логіку додатку та виконують конкретні завдання. Вони незалежні від конкретних деталей HTTP-запитів або відповідей, і можуть бути використані в різних частинах програми.
Підключення таблиць бази даних за допомогою Entity Framework відбувається у класі GreenGuardDbContext.cs (див. додаток Д, Д.1), який наслідує клас DbContext (див. Д.1, рядок 6). Основна роль цього класу –  це визначити набір DbSet властивостей, які представляють таблиці в базі даних (див. Д.1, рядок 9 - 18). Кожна властивість відображає таблицю в базі даних, і Entity Framework використовує ці властивості для виконання операцій з базою даних, таких як додавання, читання, оновлення та видалення записів. 
Розглянемо модель даних на прикладі класу AddFertilizer.cs (див. додаток Д, Д.2). Цей клас є частиною моделі даних для додавання добрива і використовується для передачі даних між клієнтом та сервером через HTTP запити. Спочатку підключається простір імен, який містить класи і атрибути для перевірки правильності даних в моделях (див. Д.2, рядок 1) за допомогою атрибутів. Для властивості FertilizerName, що відповідає за назву добрива, стоїть обмеження на максимальну та мінімальну довжину назви (див. Д.2, рядок 6). Значення властивості FertilizerQuantity, що відповідає за кількість добрива, повинно бути в межах від 0 до максимально можливого значення цілого числа (див. Д.2, рядок 8).
Далі розглянемо приклад контролера на класі PlantTypesController.cs (див. додаток Д, Д.3). Спочатку необхідно позначити, що цей клас є контролером API (див. Д.3, рядок 1). Потім треба позначити шаблон маршруту, за яким будуть доступні всі дії цього контролера (див. Д.3, рядок 2). Оскільки контролери не містять у собі бізнес логіку, вони отримують дані від клієнта та направляють його на обробку відповідному сервісу. Тому необхідно об’явити інстанцію сервісу PlantTypeService, щоб підключити його (див. Д.3, рядок 5 - 9). Далі клас містить два методи, один із них обробляє GET запит на отримання списку всіх типів рослин. Він викликає метод GetPlantTypes з сервісу PlantTypeService і повертає результат у відповідь (див. Д.3, рядок 10 - 30). Інший метод обробляє POST запит на додавання нового типу рослин. Він отримує дані нового типу рослин в об'єкті AddPlantType, перевіряє їх валідність, а потім передає їх до методу AddPlantType сервісу PlantTypeService (див. Д.3, рядок 31 - 56). Обидва методи містять коментарі з анотаціями. Перед методами стоять атрибути, що визначають, які типи користувачів мають доступ до цих запитів (див. Д.3, рядок 17, 39). Тобто для доступу до методів необхідна автентифікація користувача, яка відбувається за допомогою JWT токенів.
За створення JWT токенів відповідає сервіс JwtTokenService.cs (див. додаток Д, Д.3). Цей клас витягає значення секретного ключа з конфігураційного файлу за ключем і зберігає його в поле _key (див. Д.4, рядок 6). Потім він визначає вміст токена. Це інформація про користувача, яка включає ім'я, електронну пошту, ідентифікатор користувача та роль (див. Д.4, рядок 14 - 20). Далі необхідно вказати термін дії токена. У цьому випадку, токен буде дійсний протягом 7 днів з моменту його створення (див. Д.4, рядок 21). Потім Вказуємо об'єкт SigningCredentials, який використовує симетричний ключ для підпису токена з використанням алгоритму HMACSHA256 (див. Д.4, рядок 22). Тепер, коли токен містить всю необхідну інформацію, можна створити 	його за допомогою вказаних параметрів (див. Д.4, рядок 24).
Розглянемо функцію CalculateNextWateingAsync, що належить класу WateringScheduleService.cs та розраховує наступну оптимальну дату поливу для рослини (див. додаток Д,  Д.5). Спочатку робимо запит до контексту бази даних для отримання об'єкта рослини за ідентифікатором plantId та перевіряємо, чи він існує (див. Д.5, рядок 5 - 10). Потім отримуємо рекомендовані дані для цього типу рослин з таблиці Plant_type на основі ідентифікатора типу рослини plant.PlantTypeId (див. Д.5, рядок 11). Потім шукаємо дату останнього поливу рослини та, якщо її не існує, то повертаємо сьогоднішню дату (див. Д.5, рядок 12 - 23). Далі переходимо до самої математичної моделі, рахуємо різницю між оптимальними та поточними температурами та рівнями вологості і кількість днів, які пройшли з останньої дати поливу (див. Д.5, рядок 24 - 27). Після цього, якщо виявляється, що рослину давно не поливали, або те, що поточна вологість менше оптимальної, то починається розрахунок наступної оптимальної дати поливу. Наступна оптимальна дата поливу розраховується за математичною функцією, яка включає в себе коефіцієнт температури, коефіцієнт вологості та дату останнього поливу (див. Д.5, рядок 28 - 35). Далі отриманий результат надсилається у контролер (див. Д.5, рядок 37), або, якщо розрахувати результат не вийшло, то надсилається повідомлення про помилку (див. Д.5, рядок 40).
У даному проєкті REST використовується для реалізації сервера з низкою API-маршрутів. Кожен маршрут відповідає за роботу з конкретним ресурсом або функціональністю, а HTTP-методи (POST, GET, PUT, DELETE) визначають тип взаємодії з цими ресурсами. Усього існує 43 кінцеві точки, які дозволяють здійснювати різноманітні операції з даними через API.


4.3 Тестування


Для перевірки роботи сервера було використано Swagger — зручний інструмент, що надає широкі можливості для документування та тестування API. Крім того, Swagger надавав можливість виконувати тестові запити безпосередньо з інтерфейсу, що спрощувало процес перевірки роботи сервера. Кожен запит відповідав відповідному HTTP методу (GET, POST, PUT, DELETE), а ресурси були розподілені та ідентифіковані за допомогою URI. Сервер отримував та обробляв дані, як і очікувалось. Окрім цього, було проведено тестування, що передбачало аналіз реакцій сервера на некоректно введені дані. Тестування дозволило впевнитись, що сервер забезпечує правильні відповіді на всі запити користувача, коректно обробляє помилки, що можуть виникати під час взаємодії з ним та підтримує стандарти RESTful архітектури.

5 РОЗРОБКА ВЕБ ЧАСТИНИ


Для розробки клієнтської частини використовувалися HTML, CSS та JavaScript. Взаємодія з сервером частково реалізована за допомогою Fetch API, що дозволяє виконувати асинхронні запити до серверу і відображати отримані дані на сторінці. Для роботи з HTML-документами безпосередньо застосовувався DOM API. Логіка була розподілена на функції, такі як виклик серверних операцій, отримання та відображення даних. Система побудована на основі RESTful API, який був використаний для розробки серверної частини на попередньому етапі роботи.
Проєкт реалізований за багатошаровою архітектурою що розділяє логіку додатка на різні рівні для покращення масштабованості, підтримки і розширюваності.
Рівень презентації відповідає за представлення користувачу. Він містить HTML сторінки, які описують структуру і зміст інтерфейсу користувача, CSS файли для стилізації, а також JS скрипти для обробки інтерфейсу користувача (UI). Кожен UI скрипт відповідає за роботу з відповідною HTML сторінкою.
Рівень логіки відповідає за бізнес-логіку додатка. Він містить сервіси, які обробляють запити від UI, виконують логіку бізнесу та взаємодіють з сервером через API. Кожен сервіс відповідає за певний домен (наприклад, PlantService.js обробляє логіку, пов'язану з рослинами).
Файли (en.json і ua.json) забезпечують підтримку локалізації, дозволяючи додатку підтримувати англійську та українську мови.
Проєкт складається із компонент, які можна побачити у додатку Б на 
рисунку Б.1. Користувач взаємодіє з веб-сторінкою і викликає різні дії (натискання кнопок, введення даних і т.д.). UI скрипти, наприклад PlantUI.js (див. додаток Д, Д.6), обробляють ці дії, наприклад, збирають введені дані, перевіряють їх і викликають відповідні методи сервісів. Сервіси, наприклад PlantService.js (див. рис. 5.1), отримують запити від UI, виконують необхідну бізнес-логіку (наприклад, перевіряють правильність даних, роблять розрахунки) і взаємодіють з сервером через API для отримання або зміни даних.

 
Рисунок 5.1 – Діаграма компонент для веб частини системи

Сервіси відправляють HTTP запити на сервер. Сервер обробляє ці запити і повертає відповідні дані або підтвердження успішного виконання операцій. Після отримання відповіді від сервера сервіси передають оновлені дані назад до UI. UI оновлює відповідні частини веб-сторінки, щоб відобразити нові дані або повідомлення про помилку/успішну операцію.
Було розроблено діаграму станів для адміністратора (див. додаток. Б, рис. Б.1). Дана діаграма розроблена для відображення різних можливих станів системи, 
подій, які можуть призвести до переходів між цими станами, а також дій, які 
відбуваються у кожному з цих станів
Було створено діаграму діяльності (див. додаток. Г, рис. Г.1) для моделювання робочих процесів та дій у системі. Вона дозволяє візуалізувати послідовність кроків, необхідних для виконання певної операції або процесу. Діаграма діяльності може бути корисною для розуміння і документування бізнес-процесів, робочих процесів, алгоритмів і взаємодій між компонентами системи.









6 РОЗРОБКА МОБІЛЬНОГО ЗАСТОСУНКУ


Для розробки мобільного додатку було вибрано мову програмування Kotlin. Вона пропонує безліч переваг, включаючи компактний і зрозумілий синтаксис, підтримку нульових посилань, безпеку типів та інші [4]. У ролі середовища розробки було вибрано Android Studio. Це офіційне інтегроване середовище розробки (IDE) для платформи Android. Android Studio надає широкий спектр інструментів для розробки, налагодження та тестування Android-додатків.
Для забезпечення розширених можливостей Kotlin у Android використовується core-ktx. Цей пакет забезпечує зручний та ефективний спосіб взаємодії з різними компонентами Android за допомогою Kotlin. Використання Kotlin разом з цим пакетом дозволяє писати більш чистий, компактний та безпечний код, що прискорює розробку та зменшує ймовірність помилок.
Для забезпечення підтримки старих версій Android та сумісності з сучасними функціями використовується пакет appcompat. Цей пакет дозволяє розробникам створювати додатки, які працюють на різних версіях Android, зберігаючи при цьому спільний вигляд і поведінку. Також він забезпечує однорідний інтерфейс для користувачів на різних версіях Android, що полегшує розробку та вдосконалює враження користувачів.
Для створення інтерфейсів користувача з використанням компонентів Material Design використовується пакет material. Використання компонентів Material Design спрощує створення привабливих і сучасних інтерфейсів, забезпечуючи при цьому однорідний вигляд додатків на різних платформах.
Для створення складних інтерфейсів користувача за допомогою обмежень використовується пакет constraintlayout. ConstraintLayout дозволяє розробникам створювати гнучкі та адаптивні макети інтерфейсу, які автоматично пристосовуються до різних розмірів екранів та пристроїв. Він забезпечує високий рівень контролю над розташуванням елементів інтерфейсу, що сприяє швидкому розробці та оптимізації додатків.
Для здійснення HTTP-запитів використовується бібліотека retrofit. Retrofit спрощує роботу з мережевими запитами, забезпечуючи високий рівень абстракції та підтримку різних форматів обміну даними.
Для здійснення мережевих запитів використовується HTTP клієнт okhttp. OkHttp надає швидкий та ефективний спосіб взаємодії з веб-службами через HTTP-запити. Він забезпечує швидку та надійну роботу з мережевими запитами, маючи при цьому простий та легкий у використанні інтерфейс.
Для декодування JSON Web Token (JWT) використовується бібліотека jwtdecode. Ця бібліотека надає зручний спосіб декодування та розшифрування JWT, що дозволяє перевіряти токени авторизації. Використання JWT спрощує реалізацію механізмів аутентифікації та авторизації в додатках, забезпечуючи безпеку та конфіденційність даних.
Діаграма пакетів (див. рис. 6.1) була розроблена, щоб допомогти візуалізувати використані пакети. 








Рисунок 6.1 – Діаграма пакетів для мобільної частини системи
	Діаграма пакетів дозволяє подивитися на проект як на сукупність модулів (пакетів), що спрощує розуміння структури проекту та взаємозв'язків між його компонентами.
Архітектура проєкту побудована за принципами Clean Architecture. Це дозволяє розділити відповідальності між різними частинами додатку та зробити його більш зрозумілим, масштабованим і тестованим.
Проєкт складається із компонент, які можна побачити у додатку В на рисунку В.1. Пакет activities містить основні екранні компоненти вашого додатку. Кожна активність відповідає за певний екран і взаємодію з користувачем. Наприклад, LoginActivity (див. додаток Д, Д.8) відповідає за екран для вхожу користувача в систему.
Пакет adapters містить адаптери для RecyclerView. Адаптери відповідають за відображення списків даних у RecyclerView. Наприклад, TaskAdapter відповідає за відображення списку завдань, а PestAdapter – за відображення списку шкідників.
Пакет models містить моделі даних. Моделі представляють структуру даних, що використовується в додатку. Наприклад, у вас є моделі для рослин (Plant) та шкідників (Pest).
Пакет network містить класи для роботи з мережею. Основний компонент тут – ApiService (див. додаток Д, Д.9), який відповідає за виконання мережевих запитів. Також тут є NetworkModule, який забезпечує налаштування мережевих підключень.
Пакет services містить сервіси, які забезпечують бізнес-логіку вашого додатку. Наприклад, TasksService відповідає за операції, пов'язані із завданнями, а PestsService (див. додаток Д, Д.10) – за операції, пов'язані зі шкідниками.
Пакет util містить допоміжні класи та утиліти. Наприклад, NavigationUtils містить методи для налаштування навігаційних компонентів.
Презентаційний шар включає activities та adapters. Тут відбувається взаємодія з користувачем та відображення даних.
Доменний шар містить бізнес-логіку додатку, яку реалізовано у services. Сервіси взаємодіють із моделями та виконують основні операції, такі як отримання списків даних та їх оновлення.
Шар даних відповідає за доступ до даних і включає network. Тут реалізовано мережеві запити для отримання даних з сервера. Моделі (models) також можна віднести до цього шару, оскільки вони представляють структуру даних, що надходять з мережі.
Було розроблено діаграму станів для працівника  (див. додаток. Б, рис. Б.2). Дана діаграма розроблена для відображення різних можливих станів системи, подій, які можуть призвести до переходів між цими станами, а також дій, які відбуваються у кожному з цих станів







7 ОПИС ПРОГРАМНОЇ СИСТЕМИ
7.1 Виклик і завантаження


Щоб викликати програму, треба завантажити архів із нею, та розпакувати його. Окрім цього, треба вручну підключити базу даних Microsoft SQL server до проєкту. 
Після того, як проєкт було розархівовано, необхідно відкрити файл appsettings.json, що знаходиться за шляхом «apz-pzpi-21-1-pershyna-anastasiia\Task2\apz-pzpi-21-1-pershyna-anastasiia-task2\GreenGuard» та змінити текст рядку, який виділено на рисунку 7.1, на той, який є актуальним для входу до бази даних на даному комп’ютері.

Рисунок 7.1 – Рядок підключення бази даних у файлі appsettings.json

Після цього треба запустити серверну, веб та мобільну частини. Запустити серверну частину можна у середовищі розробки Visual Studio. Необхідно відкрити файл GreenGuard.sln, що знаходиться за шляхом «apz-pzpi-21-1-pershyna-anastasiia\Task2\apz-pzpi-21-1-pershyna-anastasiia-task2», та запустити його.
Для запуску мобільної частини необхідно відкрити код мобільної частини, що знаходиться за шляхом «apz-pzpi-21-1-pershyna-anastasiia\Task5\apz-pzpi-21-1-pershyna-anastasiia-task5», за допомогою середовища розробки Android Studio. Далі можна включати застосунок на емуляторі або на реальному телефоні.
Для запуску веб частини треба відкрити файл із назвою LoginPage.html, що знаходиться за шляхом «apz-pzpi-21-1-pershyna-anastasiia\Task4\apz-pzpi-21-1-pershyna-anastasiia-task4\src\pages».


7.2 Опис веб частини


При відкритті веб застосунку користувач бачить сторінку входу до облікового запису (див. рис. 7.2). Щоб авторизуватись, необхідно ввести правильну адресу електронної пошти та пароль. Якщо введені дані не збігаються із інформацією з бази даних, то користувач побачить повідомлення про помилку.
Рисунок 7.2 – Сторінка входу в обліковий запис

Також, у верхньому правому кутку можна побачити елемент інтерфейсу, який дозволяє змінити мову (див. рис. 7.3). Натиснувши на нього, користувач може обрати мову локалізації. На сайті присутні два варіанти мови: англійська та українська.

 
Рисунок 7.3 – Елемент інтерфейсу для зміни мови

Після того, як користувач успішно авторизувався, його перенаправляє до сторінки власного облікового запису (див. рис. 7.4). На цій сторінці він може переглядати інформацію про себе та редагувати її. 

Рисунок 7.4 – Сторінка облікового запису користувача

Користувач може перейти до сторінки резервних копій, яку можна побачити на рисунку 7.5. На цій сторінці він має змогу переглядати наявні резервні копії та, за потребою, відновлювати їх.

Рисунок 7.5 – Сторінка резервних копій

На сторінці рослин, яка зображена на рисунку 7.6, користувач має змогу переглядати та редагувати інформацію про рослини, додавати нові рослини чи видаляти наявні. При додаванні нової рослини, її статус встановлюється автоматично, у залежності від того, як поточні температура, вологість та освітлення співвідносяться з рекомендованими.

Рисунок 7.6 – Сторінка рослин

Також, на сторінці рослин користувач може отримати наступну рекомендовану дату поливу для кожної рослини (див. рис. 7.7).

Рисунок 7.7 – Повідомлення із рекомендованою датою поливу

Однією з найважливіших сторінок є сторінка завдань. На ній адміністратор, який є основним користувачем вебсайту, має змогу переглядати список завдань працівникам, редагувати інформацію про них, видаляти завдання та додавати нові (див. рис. 7.8). Далі створені завдання можуть бачити працівники в мобільному застосунку.

Рисунок 7.8 – Сторінка завдань

Під час редагування завдання, користувач може додавати і видаляти рослини та співробітників, що прив’язані до цього завдання (див. рис. 7.9). Таким чином працівники бачать виключно ті завдання, до яких вони прив’язані.
Рисунок 7.9 – Сторінка завдань (редагування завдання)

На сторінці працівників (див. рис. 7.10) адміністратор має змогу керувати працівниками, а саме редагувати інформацію про них, видаляти працівників за потреби та додавати нових.
Рисунок 7.10 – Сторінка працівників
Також, на сторінці працівників адміністратор може переглянути рекомендовану заробітну плату для кожного працівника (див. рис. 7.11).

Рисунок 7.11 – Повідомлення із рекомендованою заробітною платою

Можливість автоматичного розрахування заробітною плати є вкрай зручною функцією, яка значно спрощує роботу адміністратора, адже сама підраховує кількість робочих годин за місяць для кожного співробітника і, на основі цього, видає інформацію про рекомендовану заробітну плату.


7.3 Опис мобільного застосунку


При запуску мобільного застосунку користувач бачить перед собою екран авторизації (див. рис. 7.12). Щоб зайти в систему, необхідно ввести правильну адресу електронної пошти та пароль. Якщо вхідні дані введено неправильно, то користувач побачить повідомлення про помилку.
Також, у додатку наявна локалізація, яку теж продемонстровано на рисунку 7.12, де зображено дві версії екрану авторизації, українська та англійська. Локалізація обирається автоматично, у залежності від мови системи. Надалі у системі буде встановлена українська локалізація.
















Рисунок 7.12 – Екран авторизації (українська локалізація – справа, англійська локалізація – зліва)

Після успішної автентифікації користувач бачить перед собою екран із інформацією про себе (див. рис. 7.13). Головним користувачем мобільного застосунку є працівник компанії, яка надає послуги догляду за рослинами. На екрані із власним обліковим записом він має можливість переглядати та редагувати інформацію про себе. Він може редагувати власне ім’я, номер телефону, адресу електронної пошти, години початку та кінця робочого дня та робочі дні тижня.
У правому верхньому кутку є символ виходу, який дозволяє користувачу вийти зі свого облікового запису.














Рисунок 7.13 – Екран облікового запису

Якщо користувач натисне на кнопку «Розрахувати зарплатню», то він побачить перед собою діалогове вікно із рекомендованої заробітною платою для поточного працівника.









Рисунок 7.14 – Діалогове вікно з рекомендованої заробітною платою
На екрані зі списком рослин, який зображено на рисунку 7.15, користувач може бачити список наявних рослин. Окрім цього, на цьому екрані можна видаляти рослини, редагувати інформацію про них та додавати нові рослини.















Рисунок 7.15 – Екран облікового запису

При додаванні рослини з’являється вигулькове вікно, яке можна побачити на рисунку 7.16. Користувач обирає тип рослини з випадного списку та вписує дані про рослину.  Потім, після натисканні на кнопку «ОК», вигулькове вікно зникає. Нова рослина додається до списку з автоматично створеним статусом, який повідомляє, наскільки даній рослині підходять її поточні умови.
	Для виведення інформації у формі списку було використано патерн проектування адаптер, що дає змогу об’єктам із несумісними інтерфейсами працювати разом [5].









Рисунок 7.16 – Вигулькове вікно для додавання нової рослини

На рисунку 7.17 можна побачити екран зі списком завдань. Завданнями можна змінювати статус та виводити тільки завдання на сьогодні.














Рисунок 7.17 – Екран зі списком завдань
На рисунку 7.18 зображено екран зі списком шкідників. Користувач може додавати та видаляти шкідників із наявних рослин.















Рисунок 7.18 – Екран зі списком шкідників

Для додавання шкідника до рослини є вигулькове вікно (див. рис. 7.19).







Рисунок 7.19 – Вигулькове вікно для додавання шкідника до рослини
На рисунку 7.20 показано екран для відображення списку добрив. Користувач має змогу змінювати кількість добрива, додавати нове добриво та видаляти те, яке вже закінчилось.

















Рисунок 7.20 – Екран зі списком добрив

Отже, усього розроблений застосунок містить 6 екранів, що відповідають за різноманітні функції, необхідні для ефективної роботи працівника компанії, яка надає послуги догляду за рослинами.



ВИСНОВКИ


У результаті виконання роботи було створено програму систему для автоматизації обліку догляду за рослинами.
Демонстрацію роботи програмної системи можна подивитися за посиланням (DEMO: https://www.youtube.com/watch?v=E3Ce6KkxnmY)
Протягом виконання роботи було проведено аналіз предметної області, створено базу даних, розроблено архітектуру серверної частини за допомогою ASP.NET, веб застосунку на JavaScript та мобільного застосунку на Kotlin.
Програмна система, що була розроблена, надає користувачам доступ до низки функцій, які підвищують ефективність роботи працівників та адміністраторів компанії, яка надає послуги догляду за рослинами. Система дозволяє легко вести облік та контроль працівників, завдань, наявних рослин, добрив, шкідників та типів рослин. Користувачі можуть легко відстежувати статуси завдань, стани рослин, робочі години працівників та графіки поливів. Окрім цього, у системі наявна локалізація та можливість створення резервних копій бази даних.













ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Microsoft. SQL Server technical documentation. URL:
https://learn.microsoft.com/en-us/sql/sql-server/?view=sql-server-ver16 (дата звернення: 01.06.2024).
2. Mozilla. JavaScript Guide. URL: https://developer.mozilla.org/en-US/docs/Web/JavaScript  (дата звернення: 01.06.2024).
3. Microsoft. ASP.NET documentation. Develop ASP.NET Core apps. URL:
https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 01.06.2024).
4. Kotlin. Kotlin Programming Language: Official Documentation. URL: https://kotlinlang.org/docs/home.html (дата звернення: 01.06.2024).
5. Design Patterns: Elements of Reusable Object-Oriented Software. Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, 1995. 139 р.

 
ДОДАТОК А
Діаграми прецедентів для системи «GreenGuard»
Рисунок А.1 – Діаграма прецедентів з акторами неавторизований працівник та авторизований працівник 
 Рисунок А.2 – Діаграма прецедентів з актором адміністратор





ДОДАТОК Б
Діаграми станів системи

Рисунок Б.1 – Діаграма станів для веб частини системи
Рисунок Б.2 – Діаграма станів для мобільної частини системи
ДОДАТОК В
Діаграма компонент для мобільної частини системи

Рисунок В.1 – Діаграма компонент
ДОДАТОК Г
Діаграма діяльності для веб частини системи
Рисунок Г.1 – Діаграма діяльності
ДОДАТОК Д
Код розробленої системи
Д.1  Код класу GreenGuardDbContext.cs


1	using GreenGuard.Dto;
2	using Microsoft.EntityFrameworkCore;
3	using TaskDto = GreenGuard.Dto.TaskDto;
4	namespace GreenGuard.Data
5	{
6	public class GreenGuardDbContext : DbContext
7	{
8	public GreenGuardDbContext(DbContextOptions<GreenGuardDbContext> options) : base(options) { }
9	public DbSet<PlantDto> Plant { get; set; }
10	public DbSet<WorkerDto> Worker { get; set; }
11	public DbSet<FertilizerDto> Fertilizer { get; set; }
12	public DbSet<PestDto> Pest { get; set; }
13	public DbSet<PlantTypeDto> Plant_type { get; set; }
14	public DbSet<TaskDto> Task { get; set; }
15	public DbSet<WorkerInTaskDto> Worker_in_Task { get; set; }
16	public DbSet<PlantInTaskDto> Plant_in_Task { get; set; }
17	public DbSet<WorkingScheduleDto> Working_Schedule { get; set; }
18	public DbSet<PestInPlantDto> Pest_in_Plant { get; set; }
19	}
20	}



Д.2  Код моделі AddFertilizer.cs


1	using System.ComponentModel.DataAnnotations;
2	namespace GreenGuard.Models.Fertilizer
3	{
4	public class AddFertilizer
5	{
6	[StringLength(50, MinimumLength = 2)]
7	public required string FertilizerName { get; set; }
8	[Range(0, int.MaxValue, ErrorMessage = "Кількість має бути додатнім числом.")]
9	public int FertilizerQuantity { get; set; }
10	}
11	}


Д3. Частина коду контролера  PlantTypesControler.cs


1	[ApiController]
2	[Route("api/[controller]")]
3	public class PlantTypesController : ControllerBase
4	{
5	private readonly PlantTypeService _plantTypeService;
6	public PlantTypesController(PlantTypeService plantTypeService)
7	{
8	_plantTypeService = plantTypeService;
9	}
10	/// <summary>
11	/// Get a list of all plant types.
12	/// </summary>
13	/// <returns>
14	/// If the operation is successful, it will return an ICollection of PlantTypeDto.
15	/// If there is a bad request, it will return an ErrorDto.
16	/// </returns>
17	[Authorize(Roles = Roles.Administrator + "," + Roles.User)]
18	[HttpGet("plantTypes")]
19	public async Task<IActionResult> GetPlantTypes()
20	{
21	try
22	{
23	var plantTypes = await _plantTypeService.GetPlantTypes();
24	return Ok(plantTypes);
25	}
26	catch (Exception ex)
27	{
28	return StatusCode(500, ex.Message);
29	}
30	}
31	/// <summary>
32	/// Add a new plant type.
33	/// </summary>
34	/// <param name="model">The data to add a new plant type.</param>
35	/// <returns>
36	/// If the operation is successful, it will return a message confirming the addition.
37	/// If there is a bad request, it will return an ErrorDto.
38	/// </returns>
39	[Authorize(Roles = Roles.Administrator)]
40	[HttpPost("add")]
41	public async Task<IActionResult> AddPlantType(AddPlantType model)
42	{
43	try
44	{
45	if (!ModelState.IsValid)
46	{
47	return BadRequest(ModelState);
48	}
49	await _plantTypeService.AddPlantType(model);
50	return Ok("Plant type was successfully added");
51	}
52	catch (Exception ex)
53	{
54	return StatusCode(500, ex.Message);
55	}
56	}


Д4. Частина коду класу JwtTokenService.cs


1	public class JwtTokenService
2	{
3	private readonly string _key;
4	public JwtTokenService(IConfiguration config)
5	{
6	_key = config["Jwt:Key"];
7	}
8	public string GenerateToken(WorkerDto worker)
9	{
10	var tokenHandler = new JwtSecurityTokenHandler();
11	var key = Encoding.ASCII.GetBytes(_key);
12	var tokenDescriptor = new SecurityTokenDescriptor
13	{
14	Subject = new ClaimsIdentity(new Claim[]
15	{
16	new Claim(ClaimTypes.Name, worker.WorkerName),
17	new Claim(ClaimTypes.Email, worker.Email),
18	new Claim(ClaimTypes.NameIdentifier, worker.WorkerId.ToString()),
19	new Claim(ClaimTypes.Role, (worker.IsAdmin == null || !(bool)worker.IsAdmin)? "user" :  "admin")
20	}),
21	Expires = DateTime.UtcNow.AddDays(7), 
22	SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
23	};
24	var token = tokenHandler.CreateToken(tokenDescriptor);
25	return tokenHandler.WriteToken(token);
26	}
27	}


Д.5 Частина коду сервісу WateringService.cs


1	public async Task<WateringSchedule> CalculateNextWateringAsync(int plantId)
2	{
3	try
4	{
5	var plant = _context.Plant
6	.FirstOrDefault(p => p.PlantId == plantId);
7	if (plant == null)
8	{
9	return null;
10	}
11	var recommendedData = await _context.Plant_type.FindAsync(plant.PlantTypeId);
12	var lastWateringTask = _context.Plant_in_Task
13	.Where(pit => pit.PlantId == plantId)
14	.Select(pit => pit.TaskId)
15	.Distinct()
16	.Select(taskId => _context.Task
17	.Where(t => t.TaskId == taskId && t.TaskType == "watering")
18	.OrderByDescending(t => t.TaskDate)
19	.FirstOrDefault())
20	.FirstOrDefault();
21	if (lastWateringTask == null) {
22	return (new WateringSchedule { Date = DateTime.Now, PlantId = plantId });
23	}
24	var humidityDifference = recommendedData.OptHumidity - plant.Humidity;
25	var tempDifference = plant.Temp - recommendedData.OptTemp;
26	var daysSinceLastWatering = (DateTime.Now - lastWateringTask.TaskDate).TotalDays;
27	var nextWateringDate = lastWateringTask.TaskDate.AddDays(recommendedData.WaterFreq);
28	if (lastWateringTask == null || daysSinceLastWatering >= recommendedData.WaterFreq || humidityDifference > 0)
29	{
30	var humidityCoefficient = humidityDifference / recommendedData.OptHumidity * -1;
31	var tempCoefficient = tempDifference / recommendedData.OptTemp * -1;
32	var interval = (int)Math.Round((decimal)(humidityCoefficient + tempCoefficient) * recommendedData.WaterFreq);
33	interval = Math.Max(1, interval);
34	nextWateringDate = lastWateringTask == null ? DateTime.Now : lastWateringTask.TaskDate.AddDays(interval);
35	nextWateringDate = (nextWateringDate < DateTime.Now)? DateTime.Now : nextWateringDate;
36	}
37	return (new WateringSchedule { Date = nextWateringDate, PlantId = plantId });
38	}
39	catch (Exception ex){
40	_logger.LogError(ex, "An error occurred during calculating watering schedule");
41	throw;}


Д.6 Код PlantUI.js


1	class PlantUI {
2	    constructor(plantService) {
3	        this.plantService = plantService;
4	        this.plantsTable = document.getElementById('plants-table').getElementsByTagName('tbody')[0];
5	        this.plantTypeSelect = document.getElementById('input-plant-type');
6	        this.localizedText = {};
7	        this.plantTypes = [];
8	    }
9	
10	    async initialize() {
11	        document.querySelector('.add-button').addEventListener('click', () => this.addPlant());
12	        document.getElementById('language-select').addEventListener('change', (event) =>
13	this.fetchTranslations(event.target.value));
14	
15	        await this.fetchPlantTypes();
16	        await this.fetchPlants();
17	        await this.fetchTranslations('en'); // Default language
18	    }
19	
20	    async fetchPlants() {
21	        try {
22	            const plants = await this.plantService.fetchPlants();
23	            this.populatePlantsTable(plants);
24	        } catch (error) {
25	            console.error('Error fetching plants:', error);
26	            alert(`Error fetching plants: ${error.message}`);
27	        }
28	    }
29	
30	    async fetchPlantTypes() {
31	        try {
32	            this.plantTypes = await this.plantService.fetchPlantTypes();
33	            this.populatePlantTypeSelect(this.plantTypes);
34	        } catch (error) {
35	            console.error('Error fetching plant types:', error);
36	        }
37	    }
38	
39	    populatePlantTypeSelect(plantTypes) {
40	        this.plantTypeSelect.innerHTML = ''; // Clear existing options
41	        plantTypes.forEach(type => {
42	            const option = document.createElement('option');
43	            option.value = type.plantTypeId;
44	            option.textContent = type.plantTypeName;
45	            this.plantTypeSelect.appendChild(option);
46	        });
47	    }
48	
49	    populatePlantsTable(plants) {
50	        this.plantsTable.innerHTML = ''; // Clear existing rows
51	        plants.forEach(plant => this.addPlantRow(plant));
52	    }
53	
54	    addPlantRow(plant) {
55	        const row = this.plantsTable.insertRow();
56	        row.dataset.id = plant.plantId;
57	
58	        const typeCell = row.insertCell(0);
59	        const locationCell = row.insertCell(1);
60	        const tempCell = row.insertCell(2);
61	        const humidityCell = row.insertCell(3);
62	        const lightingCell = row.insertCell(4);
63	        const infoCell = row.insertCell(5);
64	        const stateCell = row.insertCell(6);
65	        const wateringCell = row.insertCell(7);
66	        const editCell = row.insertCell(8);
67	        const deleteCell = row.insertCell(9);
68	
69	        typeCell.textContent = plant.plantTypeName;
70	        locationCell.textContent = plant.plantLocation;
71	        tempCell.textContent = plant.temp;
72	        humidityCell.textContent = plant.humidity;
73	        lightingCell.textContent = plant.light;
74	        infoCell.textContent = plant.additionalInfo;
75	        stateCell.textContent = plant.plantState;
76	        wateringCell.innerHTML = `<button class="watering-
77	button">${this.localizedText['watering'] || 'Calculate Watering'}</button>`;
78	
79	        editCell.innerHTML = `<button class="edit-button">${this.localizedText['edit'] || 
80	'Edit'}</button>`;
81	        deleteCell.innerHTML = `<button class="delete-button">${this.localizedText['delete'] || 
82	'Delete'}</button>`;
83	
84	        wateringCell.querySelector('button').addEventListener('click', () => 
85	this.calculateWatering(plant.plantId));
86	        editCell.querySelector('button').addEventListener('click', () => this.editPlant(row, plant));
87	        deleteCell.querySelector('button').addEventListener('click', () => 
88	this.deletePlant(plant.plantId));
89	    }
90	
91	    async calculateWatering(plantId) {
92	        try {
93	            const wateringData = await this.plantService.calculateWatering(plantId);
94	            const nextWateringDate = new Date(wateringData.date).toLocaleDateString('en-CA');
95	            alert(`Next watering date: ${nextWateringDate}`);
96	        } catch (error) {
97	            console.error('Error calculating watering:', error);
98	        }
99	    }
100	
101	    editPlant(row, plant) {
102	        row.innerHTML = `
103	            <td>${plant.plantTypeName}</td>
104	            <td><input type="text" value="${plant.plantLocation}"></td>
105	            <td><input type="number" value="${plant.temp}"></td>
106	            <td><input type="number" value="${plant.humidity}"></td>
107	            <td><input type="number" value="${plant.light}"></td>
108	            <td><input type="text" value="${plant.additionalInfo}"></td>
109	            <td>${plant.plantState}</td>
110	            <td><button class="save-button">${this.localizedText['save'] || 'Save'}</button><button 
111	class="cancel-button">${this.localizedText['cancel'] || 'Cancel'}</button></td>
112	            <td></td>
113	        `;
114	
115	        row.querySelector('.save-button').addEventListener('click', () => this.savePlant(row, 
116	plant.plantId));
117	        row.querySelector('.cancel-button').addEventListener('click', () => this.fetchPlants());
118	    }
119	
120	    async savePlant(row, plantId) {
121	        const inputs = row.querySelectorAll('input');
122	        const updatedPlant = {
123	            plantLocation: inputs[0].value,
124	            temp: parseFloat(inputs[1].value),
125	            humidity: parseFloat(inputs[2].value),
126	            light: parseFloat(inputs[3].value),
127	            additionalInfo: inputs[4].value,
128	        };
129	
130	        try {
131	            await this.plantService.updatePlant(plantId, updatedPlant);
132	            await this.fetchPlants();
133	        } catch (error) {
134	            console.error('Error saving plant:', error);
135	        }
136	    }
137	
138	    async deletePlant(plantId) {
139	        try {
140	            await this.plantService.deletePlant(plantId);
141	            await this.fetchPlants();
142	        } catch (error) {
143	            console.error('Error deleting plant:', error);
144	        }
145	    }
146	
147	    async addPlant() {
148	        const typeInput = document.getElementById('input-plant-type');
149	        const locationInput = document.getElementById('input-plant-location');
150	        const tempInput = document.getElementById('input-temp');
151	        const humidityInput = document.getElementById('input-humidity');
152	        const lightInput = document.getElementById('input-light');
153	        const infoInput = document.getElementById('input-info');
154	
155	        const newPlant = {
156	            plantTypeId: parseInt(typeInput.value),
157	            plantLocation: locationInput.value,
158	            temp: parseFloat(tempInput.value),
159	            humidity: parseFloat(humidityInput.value),
160	            light: parseFloat(lightInput.value),
161	            additionalInfo: infoInput.value
162	        };
163	
164	        try {
165	            await this.plantService.addPlant(newPlant);
166	
167	            // Clear inputs after successful addition
168	            typeInput.value = '';
169	            locationInput.value = '';
170	            tempInput.value = '';
171	            humidityInput.value = '';
172	            lightInput.value = '';
173	            infoInput.value = '';
174	
175	            await this.fetchPlants();
176	        } catch (error) {
177	            console.error('Error adding plant:', error);
178	        }
179	    }
180	
181	    async fetchTranslations(lang) {
182	        try {
183	            const response = await fetch(`../../public/locales/${lang}/${lang}.json`);
184	            if (!response.ok) {
185	                throw new Error(`Error fetching translations: ${response.statusText}`);
186	            }
187	
188	            const translations = await response.json();
189	            for (const key in translations) {
190	                this.localizedText[key] = translations[key];
191	                const elements = document.querySelectorAll(`[data-translate="${key}"]`);
192	                elements.forEach(el => el.textContent = translations[key]);
193	            }
194	        } catch (error) {
195	            console.error('Error fetching translations:', error);
196	        }
197	    }
198	}
199	
200	 document.addEventListener('DOMContentLoaded', () => {
201	    const plantService = new PlantService();
202	    const plantUI = new PlantUI(plantService);
203	    plantUI.initialize();
204	});


Д.7 Код PlantService.js

1	class PlantService {
2	constructor() {
3	this.apiUrl = 'https://localhost:7042/api/Plants';
4	this.wateringUrl = 'https://localhost:7042/api/Watering';
5	this.plantTypesUrl = 'https://localhost:7042/api/PlantTypes/plantTypes';
6	}
7	
8	async fetchPlants() {
9	const token = localStorage.getItem('token');
10	const response = await fetch(`${this.apiUrl}/plants`, {
11	headers: {
12	'Authorization': `Bearer ${token}`
13	}
14	});
15	if (!response.ok) {
16	throw new Error(`Error fetching plants: ${response.statusText}`);
17	}
18	return await response.json();
19	}
20	
21	async fetchPlantTypes() {
22	const token = localStorage.getItem('token');
23	const response = await fetch(this.plantTypesUrl, {
24	headers: {
25	'Authorization': `Bearer ${token}`
26	}
27	});
28	if (!response.ok) {
29	throw new Error(`Error fetching plant types: ${response.statusText}`);
30	}
31	return await response.json();
32	}
33	
34	async calculateWatering(plantId) {
35	const token = localStorage.getItem('token');
36	const response = await fetch(`${this.wateringUrl}/${plantId}`, {
37	headers: {
38	'Authorization': `Bearer ${token}`
39	}
40	});
41	if (!response.ok) {
42	throw new Error(`Error calculating watering: ${response.statusText}`);
43	}
44	return await response.json();
45	}
46	
47	async updatePlant(plantId, updatedPlant) {
48	const token = localStorage.getItem('token');
49	const response = await fetch(`${this.apiUrl}/update/${plantId}`, {
50	method: 'PUT',
51	headers: {
52	'Content-Type': 'application/json',
53	'Authorization': `Bearer ${token}`
54	},
55	body: JSON.stringify(updatedPlant)
56	});
57	if (!response.ok) {
58	throw new Error(`Error saving plant: ${response.statusText}`);
59	}
60	}
61	
62	async deletePlant(plantId) {
63	const token = localStorage.getItem('token');
64	const response = await fetch(`${this.apiUrl}/delete/${plantId}`, {
65	method: 'DELETE',
66	headers: {
67	'Authorization': `Bearer ${token}`
68	}
69	});
70	if (!response.ok) {
71	throw new Error(`Error deleting plant: ${response.statusText}`);
72	}
73	}
74	
75	async addPlant(newPlant) {
76	const token = localStorage.getItem('token');
77	const response = await fetch(`${this.apiUrl}/add`, {
78	method: 'POST',
79	headers: {
80	'Content-Type': 'application/json',
81	'Authorization': `Bearer ${token}`
82	},
83	body: JSON.stringify(newPlant)
84	});
85	if (!response.ok) {
86	const errorData = await response.json();
87	throw new Error(`Error adding plant: ${errorData.message}`);
88	}
89	}
90	}



Д.8 Код LoginActivity.kt


1	package com.example.greenguardmobile.activities
2	import android.content.Intent
3	import android.os.Bundle
4	import android.util.Log
5	import android.widget.Button
6	import android.widget.EditText
7	import android.widget.Toast
8	import androidx.appcompat.app.AppCompatActivity
9	import com.example.greenguardmobile.R
10	import com.example.greenguardmobile.network.NetworkModule
11	import com.example.greenguardmobile.service.LoginService
12	class LoginActivity : AppCompatActivity() {
13	private lateinit var emailEditText: EditText
14	private lateinit var passwordEditText: EditText
15	private lateinit var loginButton: Button
16	private lateinit var loginService: LoginService
17	override fun onCreate(savedInstanceState: Bundle?) {
18	super.onCreate(savedInstanceState)
19	setContentView(R.layout.activity_login)
20	savedInstanceState?.let {restoreSavedInstanceState(it)
21	}
22	}
23	override fun onStart() {
24	super.onStart()
25	initializeViews()
26	initializeServices()
27	loginButton.setOnClickListener {handleLoginButtonClick()
28	}
29	}
30	override fun onResume() {
31	super.onResume()
32	emailEditText.setText(getPreferences(MODE_PRIVATE).getString("email", ""))
33	passwordEditText.setText(getPreferences(MODE_PRIVATE).getString("password", ""))
34	}
35	override fun onPause() {
36	super.onPause()
37	val preferences = getPreferences(MODE_PRIVATE).edit()
38	preferences.putString("email", emailEditText.text.toString())
39	preferences.putString("password", passwordEditText.text.toString())
40	preferences.apply()
41	}
42	override fun onSaveInstanceState(outState: Bundle) {
43	super.onSaveInstanceState(outState)
44	Log.d("LoginActivity", "onSaveInstanceState called")
45	saveInstanceState(outState)
46	}
47	private fun initializeViews() {
48	emailEditText = findViewById(R.id.emailEditText)
49	passwordEditText = findViewById(R.id.passwordEditText)
50	loginButton = findViewById(R.id.loginButton)
51	}
52	private fun initializeServices() {
53	val apiService = NetworkModule.provideApiService(this)
54	loginService = LoginService(apiService, this)
55	}
56	private fun handleLoginButtonClick() {
57	val email = emailEditText.text.toString()
58	val password = passwordEditText.text.toString()
59	if (email.isNotBlank() && password.isNotBlank()) { loginService.login(email, password, { 
60	token -> navigateToMainScreen()}, { errorMsg -> Toast.makeText(this, errorMsg, 
61	Toast.LENGTH_SHORT).show() })
62	} else { Toast.makeText(this, getResources().getString(R.string.login_toast), 
63	Toast.LENGTH_SHORT).show()
64	}
65	}
66	private fun saveInstanceState(outState: Bundle) {
67	outState.putString("email", emailEditText.text.toString())
68	outState.putString("password", passwordEditText.text.toString())
69	}
70	private fun restoreSavedInstanceState(savedInstanceState: Bundle) {
71	emailEditText.setText(savedInstanceState.getString("email"))
72	passwordEditText.setText(savedInstanceState.getString("password"))
73	}
74	private fun navigateToMainScreen() {
75	val intent = Intent(this, ProfileActivity::class.java)
76	startActivity(intent)
77	finish()
78	}
79	}


Д.9 Код ApiService.kt


1	package com.example.greenguardmobile.network
2	import com.example.greenguardmobile.models.fertilizer.AddFertilizer
3	import com.example.greenguardmobile.models.plant.AddPlant
4	import com.example.greenguardmobile.models.fertilizer.Fertilizer
5	import com.example.greenguardmobile.models.login.LoginRequest
6	import com.example.greenguardmobile.models.login.LoginResponse
7	import com.example.greenguardmobile.models.pest.Pest
8	import com.example.greenguardmobile.models.plant.Plant
9	import com.example.greenguardmobile.models.plant.PlantType
10	import com.example.greenguardmobile.models.task.Task
11	import com.example.greenguardmobile.models.task.TaskStatus
12	import com.example.greenguardmobile.models.fertilizer.UpdateFertilizerQuantity
13	import com.example.greenguardmobile.models.plant.UpdatePlant
14	import com.example.greenguardmobile.models.worker.UpdateWorker
15	import com.example.greenguardmobile.models.worker.Worker
16	import com.example.greenguardmobile.models.worker.WorkerSchedule
17	import retrofit2.Call
18	import retrofit2.http.Body
19	import retrofit2.http.DELETE
20	import retrofit2.http.GET
21	import retrofit2.http.POST
22	import retrofit2.http.PUT
23	import retrofit2.http.Path
24	import retrofit2.http.Query
25	interface ApiService {
26	@GET("api/Fertilizers/fertilizers")
27	fun getFertilizers(): Call<List<Fertilizer>>
28	@POST("api/Fertilizers/add")
29	fun addFertilizer(): Call<List<Fertilizer>>
30	@POST("api/Workers/login")
31	fun login(@Body request: LoginRequest): Call<LoginResponse>
32	@GET("api/Pests/pests")
33	fun getPests(): Call<List<Pest>>
34	@GET("api/Tasks/tasks-today/{workerId}")
35	fun getWorkerTasksToday(@Path("workerId") workerId: Int): Call<List<Task>>
36	@GET("api/Tasks/tasks/{workerId}")
37	fun getWorkerTasks(@Path("workerId") workerId: Int): Call<List<Task>>

38	@GET("api/Workers/workers/{workerId}")
39	fun getWorker(@Path("workerId") workerId: Int): Call<Worker>
40	@GET("api/WorkingSchedule/workerSchedule/{workerId}")
41	fun getWorkerSchedule(@Path("workerId") workerId: Int): Call<WorkerSchedule>
42	@GET("api/Plants/plants")
43	fun getPlants(): Call<List<Plant>>
44	@GET("api/PlantTypes/plantTypes")
45	fun getPlantTypes(): Call<List<PlantType>>
46	@PUT("api/Workers/update/{workerId}")
47	fun updateWorker(@Path("workerId") workerId: Int, @Body updatedWorker: UpdateWorker): 
48	Call<Void>
49	@PUT("api/Workers/updateSchedule/{workerId}")
50	fun updateWorkingSchedule( @Path("workerId") workerId: Int, @Body updatedSchedule: 
51	WorkerSchedule
52	): Call<Void>
53	@POST("api/Fertilizers/add")
54	fun addFertilizer(@Body addFertilizer: AddFertilizer): Call<Void>
55	@POST("api/Plants/add")
56	fun addPlant(@Body addPlant: AddPlant): Call<Void>
57	@DELETE("api/Fertilizers/delete/{fertilizerId}")
58	fun deleteFertilizer(@Path("fertilizerId") fertilizerId: Int): Call<Void>
59	@PUT("api/Fertilizers/update-quantity/{fertilizerId}")
60	fun updateFertilizerQuantity( @Path("fertilizerId") fertilizerId: Int,
61	@Body updatedFertilizerQuantity: UpdateFertilizerQuantity
62	): Call<Void>
63	@POST("api/Pests/add/{pestId}/{plantId}")
64	fun addPestToPlant(@Path("pestId") pestId: Int, @Path("plantId") plantId: Int): Call<Void>
65	@GET("api/Salary/{workerId}")
66	fun calculateSalary(@Path("workerId") workerId: Int): Call<Double>
67	@DELETE("api/Pests/delete/{pestId}/{plantId}")
68	fun deletePestFromPlant(@Path("pestId") pestId: Int, @Path("plantId") plantId: Int): 
69	Call<Void>
70	@GET("api/Tasks/status/{taskId}/{workerId}")
71	fun getTaskStatus(
72	@Path("taskId") taskId: Int,
73	@Path("workerId") workerId: Int
74	): Call<TaskStatus>
75	@PUT("api/Tasks/update-status/{taskId}/{workerId}")
76	fun updateTaskStatus(
77	@Path("taskId") taskId: Int,
78	@Path("workerId") workerId: Int,
79	@Query("taskStatus") taskStatus: String
80	): Call<Void>
81	@PUT("api/Plants/update/{plantId}")
82	fun updatePlant(@Path("plantId") plantId: Int, @Body updatedPlant: UpdatePlant): 
83	Call<Void>
84	@DELETE("api/Plants/delete/{plantId}")
85	fun deletePlant(@Path("plantId") plantId: Int): Call<Void>
86	}


Д.10 Код PestsService.kt


1	package com.example.greenguardmobile.service
2	import android.util.Log
3	import com.example.greenguardmobile.activities.PestsActivity
4	import com.example.greenguardmobile.models.plant.Plant
5	import com.example.greenguardmobile.models.pest.Pest
6	import com.example.greenguardmobile.network.ApiService
7	import retrofit2.Call
8	import retrofit2.Callback
9	import retrofit2.Response
10	class PestsService(private val apiService: ApiService, private val activity: PestsActivity) {
11	fun fetchPests(onSuccess: (List<Pest>) -> Unit) {
12	apiService.getPests().enqueue(object : Callback<List<Pest>> {
13	override fun onResponse(call: Call<List<Pest>>, response: Response<List<Pest>>) {
14	if (response.isSuccessful) {
15	response.body()?.let { pests ->
16	onSuccess(pests)
17	}
18	}
19	}
20	override fun onFailure(call: Call<List<Pest>>, t: Throwable) {
21	Log.d("fetchPests", "onFailure")
22	t.printStackTrace()
23	}
24	})
25	}
26	fun fetchPlants(onSuccess: (List<Plant>) -> Unit) {
27	apiService.getPlants().enqueue(object : Callback<List<Plant>> {
28	override fun onResponse(call: Call<List<Plant>>, response: Response<List<Plant>>) {
29	if (response.isSuccessful) {
30	response.body()?.let { plants ->
31	onSuccess(plants)
32	}
33	}
34	}
35	override fun onFailure(call: Call<List<Plant>>, t: Throwable) {
36	Log.d("fetchPlants", "onFailure")
37	t.printStackTrace()}
38	})
39	}
40	fun addPestToPlant(pestId: Int, plantId: Int, onSuccess: () -> Unit, onError: (String) -> Unit) {
41	apiService.addPestToPlant(pestId, plantId).enqueue(object : Callback<Void> {
42	override fun onResponse(call: Call<Void>, response: Response<Void>) {
43	if (response.isSuccessful) {
44	onSuccess()
45	} else {
46	val errorMsg = "Error: ${response.code()} ${response.message()}"
47	Log.e("AddToPlant", errorMsg)
48	onError(errorMsg)
49	}
50	}
51	override fun onFailure(call: Call<Void>, t: Throwable) {
52	val errorMsg = "Network error"
53	Log.e("AddToPlant", errorMsg)
54	t.printStackTrace()
55	onError(errorMsg)}
56	})
57	}
58	fun deletePestFromPlant(pestId: Int, plantId: Int, onSuccess: () -> Unit, onError: (String) -> Unit)
59	{
60	apiService.deletePestFromPlant(pestId, plantId).enqueue(object : Callback<Void> {
61	override fun onResponse(call: Call<Void>, response: Response<Void>) {
62	if (response.isSuccessful) {
63	onSuccess()
64	} else {
65	val errorMsg = "Error: ${response.code()} ${response.message()}"
66	Log.e("RemoveFromPlant", errorMsg)
67	onError(errorMsg)}
68	}
69	override fun onFailure(call: Call<Void>, t: Throwable) {
70	val errorMsg = "Network error"
71	Log.e("RemoveFromPlant", errorMsg)
72	t.printStackTrace()
73	onError(errorMsg)}
74	})
75	}
76	}
